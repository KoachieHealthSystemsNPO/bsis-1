package backingform.validator;

import java.util.Date;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;

import backingform.DonorBackingForm;
import model.donor.Donor;
import repository.DonorRepository;
import repository.SequenceNumberRepository;
import utils.CustomDateFormatter;

@Component
public class DonorBackingFormValidator extends BaseValidator<DonorBackingForm> {

  @Autowired
  private DonorRepository donorRepository;

  @Autowired
  private SequenceNumberRepository sequenceNumberRepository;

  @Override
  public void validateForm(DonorBackingForm form, Errors errors) {

    validateDonorNumber(form, errors);
    validateBirthDate(form, errors);
    validateBloodGroup(form, errors);
    validateAge(form, errors);
    
    // common validations
    commonFieldChecks(form, errors);

  }


  @Override
  public String getFormName() {
    return "donor";
  }

  private void validateAge(DonorBackingForm form, Errors errors) {
    Boolean isAgeFormatCorrect = form.isAgeFormatCorrect();
    if (isAgeFormatCorrect != null && !isAgeFormatCorrect) {
      errors.rejectValue("age", "ageFormat.incorrect", "Age should be number of years");
    }
  }

  private void validateBirthDate(DonorBackingForm form, Errors errors) {

    String birthDate = form.getBirthDate();

    try {
      if (StringUtils.isNotEmpty(birthDate)) {
        Date date = CustomDateFormatter.getDateFromString(birthDate);
        // verify Birthdate is not in the future
        if (isFutureDate(date)) {
          errors.rejectValue("donor.birthDate", "date.futureDate", "Cannot be a future date");
        }
      }
    } catch (Exception e) {
      errors.rejectValue("donor.birthDate", "dateFormat.incorrect", CustomDateFormatter.getDateErrorMessage());
    }
  }


  private void validateBloodGroup(DonorBackingForm form, Errors errors) {
    String bloodAbo = form.getBloodAbo();
    String bloodRh = form.getBloodRh();

    if (bloodAbo.isEmpty() && !bloodRh.isEmpty()) {
      errors.rejectValue("donor.bloodAbo", "bloodGroup.incomplete", "Both ABO and Rh values are required");
    }
    if (!bloodAbo.isEmpty() && bloodRh.isEmpty()) {
      errors.rejectValue("donor.bloodRh", "bloodGroup.incomplete", "Both ABO and Rh values are required");
    }

  }

  private void validateDonorNumber(DonorBackingForm form, Errors errors) {
    String donorNumber = form.getDonorNumber();
    if (StringUtils.isBlank(form.getDonorNumber()) && isFieldAutoGenerated("donorNumber")) {
      donorNumber = sequenceNumberRepository.getSequenceNumber("Donor", "donorNumber");
      form.setDonorNumber(donorNumber);
    }

    Donor existingDonor = donorRepository.findDonorByDonorNumber(donorNumber, true);
    if (existingDonor != null && !existingDonor.getId().equals(form.getId())) {
      errors.rejectValue("donor.donorNumber", "donorNumber.nonunique",
          "There exists a donor with the same donor number.");
    }
  }
}
